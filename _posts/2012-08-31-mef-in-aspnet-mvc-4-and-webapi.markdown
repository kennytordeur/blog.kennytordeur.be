---
layout: post
title: "MEF in Asp.Net MVC 4 and WebApi"
date: 2012-08-31 14:00:00 +0200
comments: true
published: true
categories: ["blog", "archives"]
tags: ["ASP.NET", "MEF", "MVC 4", "WebApi"]
alias: ["/post/MEF-in-AspNet-MVC-4-and-WebApi", "/post/mef-in-aspnet-mvc-4-and-webapi"]
---
<!-- more -->
{% include imported_disclaimer.html %}
<p>MEF stands for &ldquo;Microsoft Extensibility Framework&rdquo;. If you want an overview of MEF, you can look <a href="http://msdn.microsoft.com/en-us/library/dd460648.aspx#what_mef_provides" target="_blank">here</a>. In this post we will integrated MEF with Asp.Net MVC 4 and with the WebApi.</p>
<h2>Asp.Net MVC 4</h2>
<p>First of all you need to reference the &ldquo;System.ComponentModel.Composition.dll&rdquo; assembly which contains the implementation of MEF. Now where are going to create a MEF controller factory. Like the name says, it will be responsible to create the controller that is requested.</p>
<h1>&nbsp;</h1>
<pre class="code"><span style="color: blue;">public class </span><span style="color: #2b91af;">MefControllerFactory </span>: <span style="color: #2b91af;">DefaultControllerFactory<br />   </span>{<br />       <span style="color: blue;">private readonly </span><span style="color: #2b91af;">CompositionContainer </span>_compositionContainer;<br /><br />       <span style="color: blue;">public </span>MefControllerFactory(<span style="color: #2b91af;">CompositionContainer </span>compositionContainer)<br />       {<br />           _compositionContainer = compositionContainer;<br />       }<br /><br />       <span style="color: blue;">protected override </span><span style="color: #2b91af;">IController </span>GetControllerInstance(System.Web.Routing.<span style="color: #2b91af;">RequestContext </span>requestContext, <span style="color: #2b91af;">Type </span>controllerType)<br />       {<br />           <span style="color: blue;">var </span>export = _compositionContainer.GetExports(controllerType, <span style="color: blue;">null</span>, <span style="color: blue;">null</span>).SingleOrDefault();<br /><br />           <span style="color: #2b91af;">IController </span>result;<br /><br />           <span style="color: blue;">if </span>(<span style="color: blue;">null </span>!= export)<br />           {<br />               result = export.Value <span style="color: blue;">as </span><span style="color: #2b91af;">IController</span>;<br />           }<br />           <span style="color: blue;">else<br />           </span>{<br />               result = <span style="color: blue;">base</span>.GetControllerInstance(requestContext, controllerType);<br />               _compositionContainer.ComposeParts(result);<br />           }<br />         <br />           <span style="color: blue;">return </span>result;<br />       }<br />   }</pre>
<p><br />The MefcontrollerFactory will inherit from the DefaultControllerFactory and has a constructor that accepts a CompositionContainer. To plug in MEF, the GetControllerInstance methode will be overridden. First will look in our exports if something is defined for the requested controller type. Mark that the SingleOrDefault method is used because if more exports are defined for a controller, an exception will be throw. If this exception is thrown, something is wrong with the configuration of the CompositionContainer. If a single export is found, we&rsquo;ll get the object from the Value property.<br /><br /><br />If the export isn&rsquo;t found, the base method will be invoked. That way, the controller is created the default-way. When the controller is created, the ComposeParts method on the CompositionContainer is invoked. This will resolve the needed import for the controller.<br /><br /><br /><br />This is the object that will be injected. The GetMessage method will return a string that will be shown on the view.</p>
<pre class="code"><span style="color: blue;">public interface </span><span style="color: #2b91af;">IMyTest</span>{<br />    <span style="color: #2b91af;">String </span>GetMessage();<br />}<br /><br />[<span style="color: #2b91af;">Export</span>(<span style="color: blue;">typeof</span>(<span style="color: #2b91af;">IMyTest</span>))]<br /><span style="color: blue;">public class </span><span style="color: #2b91af;">MyTest1 </span>: <span style="color: #2b91af;">IMyTest</span>{<br />    <span style="color: blue;">public </span>MyTest1()<br />    {<br />        creationDate = <span style="color: #2b91af;">DateTime</span>.Now;<br />    }<br /><br />    <span style="color: blue;">public string </span>GetMessage()<br />    {<br />        <span style="color: blue;">return </span><span style="color: #2b91af;">String</span>.Format(<span style="color: #a31515;">"MyTest1 created at </span><span style="color: mediumseagreen;">{0}</span><span style="color: #a31515;">"</span>, creationDate.ToString(<span style="color: #a31515;">"hh:mm:ss"</span>)) ;<br />    }<br /><br />    <span style="color: blue;">private </span><span style="color: #2b91af;">DateTime </span>creationDate;<br />}</pre>
<p><br /><br />The Export attribute says to MEF that this class can be exported. The type of IMyTest is pasted as a parameter. This indicates the contract that is used. So when an IMyTest is requested from MEF, an object of MyTest1 is returned. </p>
<pre class="code">[<span style="color: #2b91af;">Export</span>]<br /><span style="color: blue;">public class </span><span style="color: #2b91af;">HomeController </span>: <span style="color: #2b91af;">Controller</span>{<br />    [<span style="color: #2b91af;">Import</span>]<br />    <span style="color: blue;">private </span><span style="color: #2b91af;">IMyTest </span>_myTest;<br /><br />    <span style="color: blue;">public </span><span style="color: #2b91af;">ActionResult </span>Index()<br />    {<br />        ViewBag.Message = _myTest.GetMessage();<br /><br />        <span style="color: blue;">return </span>View();<br />    }<br />}</pre>
<p><br />The HomeController is marked for export and an import attribute is put on the &ldquo;_mytest&rdquo; property. Of course we still need to configure MVC to use our MefControllerFactorty. To accomplish this, is created a static class with one static public method (RegisterMef). This method will create a Mef CompositionContainer and pass this container to the MefControllerFactory. This MefControllerFactory will be set as the controller factory for MVC. To configure the CompositionContainer an AssemblyCatalog is used.</p>
<pre class="code"><span style="color: blue;">public static class </span><span style="color: #2b91af;">MefConfig</span>{<br />    <span style="color: blue;">public static void </span>RegisterMef()<br />    {<br />        <span style="color: blue;">var </span>container = ConfigureContainer();<br /><br />        <span style="color: #2b91af;">ControllerBuilder</span>.Current.SetControllerFactory(<span style="color: blue;">new </span><span style="color: #2b91af;">MefControllerFactory</span>(container));<br />        <br />        <span style="color: blue;">var </span>dependencyResolver = System.Web.Http.<span style="color: #2b91af;">GlobalConfiguration</span>.Configuration.DependencyResolver;<br />    }<br /><br />    <span style="color: blue;">private static </span><span style="color: #2b91af;">CompositionContainer </span>ConfigureContainer()<br />    {<br />        <span style="color: blue;">var </span>assemblyCatalog = <span style="color: blue;">new </span><span style="color: #2b91af;">AssemblyCatalog</span>(<span style="color: #2b91af;">Assembly</span>.GetExecutingAssembly());<br />        <span style="color: blue;">var </span>container = <span style="color: blue;">new </span><span style="color: #2b91af;">CompositionContainer</span>(assemblyCatalog);<br />        <br />        <span style="color: blue;">return </span>container;<br />    }<br />}</pre>
<p><br />The RegisterMef method will be called form the Application_Start method that resides in the global.asax.</p>
<pre class="code"><span style="color: blue;">public class </span><span style="color: #2b91af;">MvcApplication </span>: System.Web.<span style="color: #2b91af;">HttpApplication</span>{<br /><span style="color: blue;">     protected void </span>Application_Start()<br />     {<br />        <span style="color: #2b91af;">AreaRegistration</span>.RegisterAllAreas();<br /><br />        <span style="color: #2b91af;">MefConfig</span>.RegisterMef();<br /><br />        <span style="color: #2b91af;">WebApiConfig</span>.Register(<span style="color: #2b91af;">GlobalConfiguration</span>.Configuration);<br />        <span style="color: #2b91af;">FilterConfig</span>.RegisterGlobalFilters(<span style="color: #2b91af;">GlobalFilters</span>.Filters);<br />        <span style="color: #2b91af;">RouteConfig</span>.RegisterRoutes(<span style="color: #2b91af;">RouteTable</span>.Routes);<br />        <span style="color: #2b91af;">BundleConfig</span>.RegisterBundles(<span style="color: #2b91af;">BundleTable</span>.Bundles);<br />        <span style="color: #2b91af;">AuthConfig</span>.RegisterAuth();<br />     }<br />}</pre>
<p><br />When the Index action for the HomeController is requested through the browser, everything works just fine but when it is requested it again, an exception is thrown. <br /><br /></p>
<h4><em>A single instance of controller 'MvcApplication5.Controllers.HomeController' cannot be used to handle multiple requests. If a custom controller factory is in use, make sure that it creates a new instance of the controller for each request.</em></h4>
<p><br />This exception is thrown because the lifetime of the controller is linked to the lifetime of the CompositionContainer. The container keeps a reference to all the objects that it has created. If the same object is requested, the reference of the previous object is given. There are 2 ways to solve this problem. <br /><br />You could pass an instance of a ComposablePartCatalog (in this case the AssemblyCatalog) to the MefControllerFactorty. Then in the &ldquo;GetControllerInstance&rdquo; method always compose a new CompositionContainer to resolve the controller. Personally I'm not really found about that.<br /><br />The other solution is to use a CreatonPolicy. If we put a CreationPolicy of &ldquo;NonShared&rdquo; on the HomeController, a new instance of the HomeController is created from scratch every time it gets requested. Since this a standard feature of MEF, I'll use this solution.</p>
<pre class="code">[<span style="color: #2b91af;">Export</span>]<br />[<span style="color: #2b91af;">PartCreationPolicy</span>(<span style="color: #2b91af;">CreationPolicy</span>.NonShared)]<br /><span style="color: blue;">public class </span><span style="color: #2b91af;">HomeController </span>: <span style="color: #2b91af;">Controller</span>{<br />    [<span style="color: #2b91af;">Import</span>]<br />    <span style="color: blue;">private </span><span style="color: #2b91af;">IMyTest </span>_myTest;<br /><br />    <span style="color: blue;">public </span><span style="color: #2b91af;">ActionResult </span>Index()<br />    {<br />        ViewBag.Message = _myTest.GetMessage();<br /><br />        <span style="color: blue;">return </span>View();<br />    }<br />}</pre>
<p><br />Now we can request the controller as many times as we want.<br /><br /></p>
<h1>&nbsp;</h1>
<p>&nbsp;</p>
<h1>WebApi</h1>
<p><br />This is the created WebApi controller. Mark that the controller also has a CreationPolicy defined. This is for the same reason a mentioned above.</p>
<pre class="code">[<span style="color: #2b91af;">Export</span>]<br />[<span style="color: #2b91af;">PartCreationPolicy</span>(<span style="color: #2b91af;">CreationPolicy</span>.NonShared)]<br /><span style="color: blue;">public class </span><span style="color: #2b91af;">HomeController </span>: <span style="color: #2b91af;">ApiController</span>{<br />    [<span style="color: #2b91af;">Import</span>]<br />    <span style="color: blue;">private </span><span style="color: #2b91af;">IMyTest </span>_myTest;<br /><br />    <span style="color: blue;">public </span><span style="color: #2b91af;">String </span>GetMessage()<br />    {<br />        <span style="color: blue;">return </span>_myTest.GetMessage();<br />    }<br />}</pre>
<p><br />To plug in MEF in the WebApi a object needs to be created from the System.Web.Http.Dependencies.IDependencyResolver interface. This is how the object looks like.</p>
<pre class="code"><span style="color: blue;">public class </span><span style="color: #2b91af;">MefDependencyResolver </span>: <span style="color: #2b91af;">IDependencyResolver</span>{<br />    <span style="color: blue;">private readonly </span><span style="color: #2b91af;">CompositionContainer </span>_container;<br />    <br />    <span style="color: blue;">public </span>MefDependencyResolver(<span style="color: #2b91af;">CompositionContainer </span>container)<br />    {<br />        _container = container;<br />    }<br /><br />    <span style="color: blue;">public </span><span style="color: #2b91af;">IDependencyScope </span>BeginScope()<br />    {<br />        <span style="color: blue;">return this</span>;<br />    }<br /><br />    <span style="color: blue;">public object </span>GetService(<span style="color: #2b91af;">Type </span>serviceType)<br />    {<br />        <span style="color: blue;">var </span>export = _container.GetExports(serviceType, <span style="color: blue;">null</span>, <span style="color: blue;">null</span>).SingleOrDefault();<br /><br />        <span style="color: blue;">return null </span>!= export ? export.Value : <span style="color: blue;">null</span>;<br />    }<br /><br />    <span style="color: blue;">public </span><span style="color: #2b91af;">IEnumerable</span>&lt;<span style="color: blue;">object</span>&gt; GetServices(<span style="color: #2b91af;">Type </span>serviceType)<br />    {<br />        <span style="color: blue;">var </span>exports =_container.GetExports(serviceType, <span style="color: blue;">null</span>, <span style="color: blue;">null</span>);<br />        <span style="color: blue;">var </span>createdObjects = <span style="color: blue;">new </span><span style="color: #2b91af;">List</span>&lt;<span style="color: blue;">object</span>&gt;();<br /><br />        <span style="color: blue;">if </span>( exports.Any())<br />        {<br />            <span style="color: blue;">foreach </span>(<span style="color: blue;">var </span>export <span style="color: blue;">in </span>exports)<br />            {<br />                createdObjects.Add(export.Value);<br />            }<br />        }<br /><br />        <span style="color: blue;">return </span>createdObjects;<br />    }<br /><br />    <span style="color: blue;">public void </span>Dispose()<br />    {<br />        ;<br />    }<br />}</pre>
<p><br /><br /><br />The &ldquo;BeginScope&rdquo; method returns a scope in with the create objects will life. Since we are going to use MEF to control the lifetime of the created objects, we can do a return of &ldquo;this&rdquo;.&nbsp; We can do this because the IDependencyResolver inherits form IDependencyScope. If you really need a limited scope per request, the &ldquo;BeginScope&rdquo; method always needs to return a new object of type IDependencyScope.<br /><br />You also need to implement a &ldquo;Dispose&rdquo; method to release the used resources. In the MefDependencyResolver, it isn&rsquo;t implemented. This is because we return the current instance in the &ldquo;BeginScope&rdquo; method. If we disposed the CompositionContainer, we could only request the service once.<br /><br /><br />Right now, the only thing needed, is the register the create MefDependencyResolver. This will be done in the modified MefConfig class.</p>
<pre class="code"><span style="color: blue;">public static class </span><span style="color: #2b91af;">MefConfig<br />   </span>{<br />       <span style="color: blue;">public static void </span>RegisterMef()<br />       {<br />           <span style="color: blue;">var </span>container = ConfigureContainer();<br /><br />           <span style="color: #2b91af;">ControllerBuilder</span>.Current.SetControllerFactory(<span style="color: blue;">new </span><span style="color: #2b91af;">MefControllerFactory</span>(container));<br />           <br />           <span style="color: blue;">var </span>dependencyResolver = System.Web.Http.<span style="color: #2b91af;">GlobalConfiguration</span>.Configuration.DependencyResolver;<br />           System.Web.Http.<span style="color: #2b91af;">GlobalConfiguration</span>.Configuration.DependencyResolver = <span style="color: blue;">new </span><span style="color: #2b91af;">MefDependencyResolver</span>(container);<br />       }<br /><br />       <span style="color: blue;">private static </span><span style="color: #2b91af;">CompositionContainer </span>ConfigureContainer()<br />       {<br />           <span style="color: blue;">var </span>assemblyCatalog = <span style="color: blue;">new </span><span style="color: #2b91af;">AssemblyCatalog</span>(<span style="color: #2b91af;">Assembly</span>.GetExecutingAssembly());<br />           <span style="color: blue;">var </span>container = <span style="color: blue;">new </span><span style="color: #2b91af;">CompositionContainer</span>(assemblyCatalog);<br />           <br />           <span style="color: blue;">return </span>container;<br />       }<br />   }</pre>
<p><br /><br /><br />The example can be downloaded from <a href="http://dl.dropbox.com/u/41091233/Blog/MEF%20in%20Asp.Net%20MVC%204%20and%20WebApi/MEF%20Asp.Net%20MVC%204%20and%20WebApi.rar" target="_blank">here</a>.</p>
